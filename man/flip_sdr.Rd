% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/flip_sdr.R
\name{flip_sdr}
\alias{flip_sdr}
\title{Flip SDR Estimator}
\usage{
flip_sdr(
  data,
  trt,
  outcome,
  baseline = NULL,
  time_vary = NULL,
  cens = NULL,
  compete = NULL,
  target_regime = NULL,
  overlap = FALSE,
  trimming_threshold,
  smoothing_constant,
  k = Inf,
  outcome_type = c("binomial", "continuous", "survival"),
  id = NULL,
  bounds = NULL,
  learners_outcome = "SL.glm",
  learners_trt = "SL.glm",
  folds = 10,
  weights = NULL,
  control = lmtp_control(),
  life = FALSE
)
}
\arguments{
\item{data}{A \code{data.frame} containing all relevant variables.}

\item{trt}{Character vector of treatment column names (time‐varying, each ending in \code{"_tXX"}).}

\item{outcome}{Name of the outcome column (character).}

\item{baseline}{Character vector of baseline covariate names, or \code{NULL} if none.}

\item{time_vary}{Character vector of time‐varying covariate names (each ending in \code{"_tXX"}), or \code{NULL}.}

\item{cens}{Name of the censoring indicator column (character), or \code{NULL} if no censoring.}

\item{compete}{Name of the competing event indicator column (character), or \code{NULL} if none.}

\item{target_regime}{Vector or list specifying the target treatment regime at each time point.
Must have length equal to \code{length(trt)} (or \code{task$tau} internally).}

\item{overlap}{Logical; if \code{TRUE}, use overlap weights, otherwise use smooth trimming.}

\item{trimming_threshold}{Numeric threshold for smooth trimming. Values outside
this threshold receive zero weight under smooth trimming.
Ignored if \code{overlap = TRUE}.}

\item{smoothing_constant}{Numeric smoothing parameter (larger values --> weight function is closer to a
hard indicator). Ignored if \code{overlap = TRUE}.}

\item{k}{Integer (or \code{Inf}); history window size. If \code{Inf}, use the full history.}

\item{outcome_type}{Character; one of \code{c("binomial", "continuous", "survival")}.
Determines how pseudo‐outcomes are constructed and whether bounding applies.}

\item{id}{Name of the subject‐identifier column (character), or \code{NULL}.
If \code{NULL}, no ID is stored in the returned \code{ife} object.}

\item{bounds}{Optional numeric vector of length 2 (\code{c(lower, upper)}) giving
outcome bounds. If \code{NULL}, no bounding is enforced on regression fits.}

\item{learners_outcome}{Character vector of SuperLearner (or other) learners to use for the
sequential outcome regression steps.}

\item{learners_trt}{Character vector of SuperLearner (or other) learners to use for
the time‐varying treatment (propensity) models.}

\item{folds}{Integer ≥ 2; number of cross‐fitting folds for both propensity and
outcome regressions.}

\item{weights}{Optional numeric vector of sample weights (length = \code{nrow(data)}).
If \code{NULL}, no sample weighting is applied.}

\item{control}{An \code{lmtp_control} object controlling learner options,
parallelization, and other fitting parameters.}

\item{life}{Logical; if \code{TRUE}, the returned list will also include
\code{$task} (the \code{LmtpTask} object) and \code{$control}, so that
one can continue estimation via \code{flip_sdr_second_PO} or
\code{flip_sdr_treatment}. If \code{FALSE} (default), only final
outputs are returned.}
}
\value{
A list of class \code{flip} containing:
\describe{
\item{\code{estimator}}{Character; the string \code{"SDR"} indicating this is the SDR flip estimator.}
\item{\code{ifvalues}}{Numeric vector of length \code{nrow(data)} containing the final
pseudo‐outcome (influence‐function) values at time $t = 1$ after back‐substitution.}
\item{\code{estimate}}{An \code{\link[ife]{ife}} object with
\code{x = mean(ifvalues)} and \code{eif = ifvalues}, indexed by \code{id} if provided.}
\item{\code{prop_scores}}{Numeric matrix of dimension $n \times \tau$, containing the cross‐fitted
estimated propensity scores at each time point.}
\item{\code{fits_prop}}{A list of length \code{folds}, where each entry is itself a list of fitted
propensity‐model objects (one per time point) from \code{cf_propensity}.}
\item{\code{fits_m}}{A list of length $\tau$, where each entry is the list of fitted outcome‐regression
objects (one per fold) returned by \code{cf_sequential_regression()} at that time point.}
\item{\code{outcome_type}}{Character; same as the \code{outcome_type} argument, indicating \code{"binomial"},
\code{"continuous"}, or \code{"survival"}.}
\item{\code{task}}{(Only if \code{life = TRUE}.) The \code{LmtpTask} object constructed internally,
containing original data, shift plan, and relevant metadata (used for continuation).}
\item{\code{control}}{(Only if \code{life = TRUE}.) The \code{lmtp_control} object used in this run.}
}
}
\description{
Estimate the “flip” effect via a sequentially doubly robust (SDR) procedure that
applies either smooth trimming or overlap weighting at each time point.
}
\details{
The \code{flip_sdr} function implements a sequentially doubly robust estimator for a “flip” intervention:
for each time $t = 1, \dots, \tau$, one either trims units whose estimated density ratio falls below
\code{trimming_threshold} (with smoothing via \code{smoothing_constant}) or applies overlap weighting
if \code{overlap = TRUE}.  After estimating all propensity scores via cross‐fitting (in \code{cf_propensity}),
it computes the density ratios and \(\phi\)-scores (in \code{compute_q_phi_score}), then proceeds
backward from $t = \tau$ to $t = 1$, at each step cross‐fitting a regression of the current pseudo‐outcome
on covariates to update the pseudo‐outcome for the next time step (in \code{cf_sequential_regression}).
The final pseudo‐outcome at time $t = 1$ serves as an influence‐function estimate for the overall flip effect.

If \code{life = TRUE}, the returned list also includes \code{$task} and \code{$control} so that
one can call \code{flip_sdr_second_PO()} or \code{flip_sdr_treatment()} to continue estimation
under a new target regime or to obtain a treatment‐level effect at a specific final time point,
but using the same fold and propensity score estimate information.
}
\examples{
\dontrun{
# Basic usage with smooth trimming:
df <- sim_t4
df$A_1 <- rbinom(n = nrow(df), size = 1, prob = 0.3)
df$A_2 <- rbinom(n = nrow(df), size = 1, prob = 0.5)
df$A_3 <- rbinom(n = nrow(df), size = 1, prob = 0.7)
df$A_4 <- rbinom(n = nrow(df), size = 1, prob = 0.9)
df$X <- runif(n = nrow(df))

flip_sdr(
data = df,
trt = c("A_1", "A_2", "A_3", "A_4"),
outcome = "Y",
baseline = c("X"),
time_vary = list(c("L_1"), c("L_2"), c("L_3"), c("L_4")),
cens               = NULL,
compete            = NULL,
id = "ID",
target_regime      = rep(1, 4),        # always treat
overlap            = FALSE,
trimming_threshold = 0.1,
smoothing_constant = 5,
outcome_type       = "continuous",
learners_outcome   = "SL.glm",
learners_trt       = "SL.glm",
folds              = 10
)
}

}
